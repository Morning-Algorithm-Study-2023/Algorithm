## 소요시간, 메모리
테스트 1 〉	통과 (2.60ms, 84.2MB)
테스트 2 〉	통과 (1.55ms, 77.3MB)
테스트 3 〉	통과 (0.41ms, 72.4MB)
테스트 4 〉	통과 (1.16ms, 76.2MB)
테스트 5 〉	통과 (0.99ms, 76.2MB)
테스트 6 〉	통과 (0.34ms, 76.1MB)
테스트 7 〉	통과 (2.76ms, 75.7MB)
테스트 8 〉	통과 (0.40ms, 71.1MB)
테스트 9 〉	통과 (0.99ms, 74.9MB)
테스트 10 〉	통과 (4.12ms, 71.5MB)
테스트 11 〉	통과 (0.12ms, 77.9MB)
테스트 12 〉	통과 (0.21ms, 74.7MB)
테스트 13 〉	통과 (0.21ms, 72.3MB)
테스트 14 〉	통과 (0.48ms, 72.1MB)
테스트 15 〉	통과 (0.27ms, 74.4MB)
테스트 16 〉	통과 (1.19ms, 73.3MB)
테스트 17 〉	통과 (0.36ms, 65.6MB)
테스트 18 〉	통과 (0.34ms, 76.8MB)
테스트 19 〉	통과 (1.32ms, 78.9MB)
테스트 20 〉	통과 (0.24ms, 77.5MB)
테스트 21 〉	통과 (2.36ms, 73.4MB)
테스트 22 〉	통과 (0.64ms, 76.4MB)
테스트 23 〉	통과 (0.38ms, 72.9MB)
테스트 24 〉	통과 (2.93ms, 83MB)
테스트 25 〉	통과 (1.33ms, 80.6MB)
테스트 26 〉	통과 (1.46ms, 76MB)
테스트 27 〉	통과 (0.38ms, 78.9MB)

## 풀이
BFS(Breadth-First Search) 알고리즘을 활용하여 문제를 해결합니다. BFS는 그래프나 트리에서 최단 경로를 찾는 알고리즘 중 하나로, 큐를 활용하여 너비 우선으로 탐색하는 방식입니다.

1. 보드의 크기 및 초기 설정
   - 보드의 세로 크기(`ySize`)와 가로 크기(`xSize`)를 구합니다.
   - 방문 체크를 위한 `visited` 배열을 생성합니다.
   - BFS를 위한 큐 `queue`를 생성합니다.

2. 로봇의 초기 위치 설정
   - 보드를 순회하며 'R'인 위치를 찾아 큐에 추가하고 방문 체크를 합니다.

3. BFS 수행
   - 큐가 빌 때까지 반복합니다.
   - 큐에서 로봇의 현재 위치와 레벨(이동 횟수) 정보를 가져옵니다.
   - 현재 위치가 목적지 'G'인 경우, 현재 레벨(이동 횟수)을 반환합니다.
   - 현재 위치에서 상하좌우로 이동 가능한 최대 거리를 찾습니다.
     - Right 방향으로 이동 가능한 최대 거리를 찾습니다. 이동한 위치를 큐에 추가하고 방문 체크합니다.
     - UP 방향으로 이동 가능한 최대 거리를 찾습니다. 이동한 위치를 큐에 추가하고 방문 체크합니다.
     - Left 방향으로 이동 가능한 최대 거리를 찾습니다. 이동한 위치를 큐에 추가하고 방문 체크합니다.
     - Down 방향으로 이동 가능한 최대 거리를 찾습니다. 이동한 위치를 큐에 추가하고 방문 체크합니다.
   - 위 과정을 반복하면서 BFS 탐색을 진행합니다.

4. 목적지에 도달하지 못한 경우
   - BFS 탐색을 모두 마쳤는데도 목적지 'G'에 도달하지 못한 경우 `-1`을 반환합니다.


## 코드


```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n + 1][m + 1];
        int[][] dp = new int[n + 1][m + 1];

        // 물 웅덩이가 있는 위치를 -1로 표시
        for (int[] puddle : puddles) {
            int x = puddle[0];
            int y = puddle[1];
            map[y][x] = -1;
        }

        dp[1][0] = 1; // 시작점 초기화

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 물 웅덩이가 있는 위치면 해당 지점의 경로 개수는 0
                if (map[i][j] == -1) {
                    dp[i][j] = 0;
                } else {
                    // 이전 지점에서 오는 경우와 위쪽 지점에서 오는 경우의 경로 개수를 더함
                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 1000000007;
                }
            }
        }

        return dp[n][m];
    }
}

```
