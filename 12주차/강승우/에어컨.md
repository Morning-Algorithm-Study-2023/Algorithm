## 첫 시도
bfs를 이용하여 해결하려 했으나 onboard의 길이가 최대 1000이라 시간초과
```java
import java.util.*;

class Solution {
    public int solution(int temperature, int t1, int t2, int a, int b, int[] onboard) {
        int answer = Integer.MAX_VALUE;
        
        int last=0;
        for(int i=0; i<onboard.length; i++){
            if(onboard[i]==1) last=i;
        }
        
        Queue<Node> q=new LinkedList<>();
        q.add(new Node(0, temperature, 0));
        while(!q.isEmpty()){
            Node cur=q.poll();
            
            if(cur.len==onboard.length-1){
                if(onboard[onboard.length-1]==1){
                    if(t1<=cur.temper && cur.temper<=t2){
                        answer=Math.min(answer, cur.total);
                    }
                }
                else{
                    answer=Math.min(answer, cur.total);
                }
                continue;
                    
            }
            
            if(cur.len>=last){
                if(Math.abs(cur.temper-t2)<Math.abs(cur.temper-t1)){
                    // 끄기
                    q.add(new Node(cur.len+1, cur.temper+1, cur.total));
                }
                else if(Math.abs(cur.temper-t2)>Math.abs(cur.temper-t1)){
                    // 끄기
                    q.add(new Node(cur.len+1, cur.temper-1, cur.total));
                }
            }
            
            if(cur.temper>t2){
                q.add(new Node(cur.len+1, cur.temper-1, cur.total+a));
                continue;
            }
            else if(cur.temper<t1){
                q.add(new Node(cur.len+1, cur.temper+1, cur.total+a));
                continue;
            }
            else{
                q.add(new Node(cur.len+1, cur.temper, cur.total+b));
                // 현재 온도가 t2에 가까운 경우
                if(Math.abs(cur.temper-t2)<Math.abs(cur.temper-t1)){
                    // 끄기
                    q.add(new Node(cur.len+1, cur.temper+1, cur.total));
                    // 계속 낮추기
                    q.add(new Node(cur.len+1, cur.temper-1, cur.total+a));
                }
                else if(Math.abs(cur.temper-t2)>Math.abs(cur.temper-t1)){
                    // 끄기
                    q.add(new Node(cur.len+1, cur.temper-1, cur.total));
                    // 계속 올리기
                    q.add(new Node(cur.len+1, cur.temper+1, cur.total+a));
                }
                
            }
        }
        
        
        return answer;
    }
    
    class Node{
        int len;
        int temper;
        int total;
        
        Node(int len, int temper, int total){
            this.len=len;
            this.temper=temper;
            this.total=total;
        }
    }
}
```
