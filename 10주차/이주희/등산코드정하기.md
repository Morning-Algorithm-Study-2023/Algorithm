## 소요시간, 메모리
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/3c8b3dee-d997-4c54-bd8c-0dc97e68b703)

## 코드
```Java
import java.util.*;

/*
산봉우리에서 각 출입구까지 가는 경로 구하기 (bfs, 가장 긴 값)
*/

class Solution {
    
    int n, start;
    int[] answer;
    ArrayList<Edge>[] adjList;
    boolean[] isSummit, isGate;
    final int MAX_VALUE = 10_000_000;
    
    class Edge {
        int vertex;
        int cost;
        
        Edge(int vertex, int cost) {
            this.vertex = vertex;
            this.cost = cost;
        }
    }
    
    public int[] solution(int n, int[][] paths, int[] gates, int[] summits) {
        this.n = n;
        answer = new int[]{-1, MAX_VALUE};
        
        //인접리스트 생성
        adjList = new ArrayList[n+1];
        for(int i=1; i<=n; i++){
            adjList[i] = new ArrayList<Edge>();
        }
        
        for(int[] path : paths) {
            int from = path[0];
            int to = path[1];
            int cost = path[2];
            
            adjList[from].add(new Edge(to, cost));
            adjList[to].add(new Edge(from, cost));
        }
        //인접리스트 생성 End
       
        Arrays.sort(summits);           //답이 되는 등산코드가 여러 개라면, 산봉우리가 가장 낮은 등산코스를 리턴하기 위해 오름차순 정렬
        isSummit = new boolean[n+1];    //산봉우리인지 판별
        for(int s : summits) {
            isSummit[s] = true;
        }
        isGate = new boolean[n+1];      //출발지인지 판별
        for(int g : gates) {
            isGate[g] = true;
        }
        
        // 탐색 시작
        for(int s : summits) {
            // bfs(s);
            start = s;
            int[] dist = new int[n+1];
            Arrays.fill(dist, MAX_VALUE);
            dist[s] = 0;
            dfs(s, dist, 0);
        }
        
        return answer;
    }
    
    void dfs(int now, int[] dist, int max) {
        if(answer[1] <= max) return;    //이미 구한 최솟값보다 현재 경로의 값이 더 크다면 continue
        
        if(isGate[now]) {            //출발지 도착 
            answer[0] = start;
            answer[1] = max; 
            return;
        }
        
        for(Edge e : adjList[now]) {
            if(isSummit[e.vertex]) continue;   //산봉우리면 continue
            if(dist[e.vertex] > e.cost) {
                int ori = dist[e.vertex];
                dist[e.vertex] = e.cost;
                int cost = max >= e.cost ? max : e.cost;
                dfs(e.vertex, dist, cost);
                dist[e.vertex] = ori;
            }
        }
    }
    
//     void bfs(int start) {
//         Queue<int[]> que = new ArrayDeque<>();
//         que.add(new int[]{start, 0});   //현재 지점, 가장 긴 거리
//         int[] dist = new int[n+1];
//         Arrays.fill(dist, MAX_VALUE);
//         dist[start] = 0;
        
//         while(!que.isEmpty()) {
//             int[] now = que.poll();
            
//             if(answer[1] <= now[1]) {
//                 continue;    //이미 구한 최솟값보다 큰 경로
//             }
            
//             if(isGate[now[0]]) {                //출발지 도착 
//                 answer[0] = start;
//                 answer[1] = now[1]; 
//                 continue;
//             }
            
//             for(Edge e : adjList[now[0]]) {
//                 if(isSummit[e.vertex]) continue;   //산봉우리면 continue
//                 if(dist[e.vertex] > e.cost) {
//                     dist[e.vertex] = e.cost;
//                     int max = now[1] >= e.cost ? now[1] : e.cost;
//                     que.add(new int[]{e.vertex, max});
//                 }
//             }
//         }
//     }
}
```
