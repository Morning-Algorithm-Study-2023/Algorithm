## 코드
```Java
import java.util.*;

class Solution {
    
    int n, answer;
    int[][] board;
    int[] cur;
    
    public int solution(int[][] board, int r, int c) {
        n = board.length;
        this.board = board;
        
        int left = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<n; j++) {
                if(board[i][j] != 0) {
                    left++;
                }
            }
        }
        
        answer = 0;
        cur = new int[]{r, c};
        while(left > 0) {
            int target = board[cur[0]][cur[1]]; //타겟이 0이면, 카드를 찾아야 한다. 타겟이 숫자면 같은 숫자를 찾아야 한다. 
            int res = bfs(target);
            if(res == -1) break;
            left -= bfs(target);
            if(left <= 0) break;
        }
        
        return answer;
    }
    
    int[] dx = {-1, 0, 1, 0};  //상, 우, 하, 좌
    int[] dy = {0, 1, 0, -1};
    
    int bfs(int target) {
        Queue<int[]> que = new ArrayDeque<>();
        que.add(cur);
        int[][] cnt = new int[n][n];
        cnt[cur[0]][cur[1]] = 1;
        
        while(!que.isEmpty()) {
            int[] now = que.poll();
            
            if(target==0 && board[now[0]][now[1]] != 0) {   //카드 찾음
                answer += cnt[now[0]][now[1]]-1;  //이동
                cur[0] = now[0]; cur[1] = now[1];
                return 0;
            } else if(target != 0 && board[now[0]][now[1]] == target && (now[0] != cur[0] && now[1] != cur[1])) {   //짝 찾음
                answer += cnt[now[0]][now[1]]-1;  //이동
                answer += 2;        //enter연산
                board[now[0]][now[1]] = 0;      //제거
                board[cur[0]][cur[1]] = 0;      //제거
                cur[0] = now[0]; cur[1] = now[1];
                return 2;
            }
            
            //ctrl
            for(int d=0; d<4; d++) {
                int nx = now[0], ny = now[1];
                
                while(true) {
                    nx += dx[d];
                    ny += dy[d];
                    
                    if(nx<0 || nx>=n || ny<0 || ny>=n) {
                        nx-=dx[d]; ny-=dy[d];
                        break;
                    }
                    
                    if(board[nx][ny] != 0) break;
                }
                
                if(nx==now[0] && ny==now[1]) continue;    //이동할 수 없음
                if(cnt[nx][ny]!=0) continue;    //이미 방문함
                
                cnt[nx][ny] = cnt[now[0]][now[1]]+1;
                que.add(new int[]{nx, ny});
            }
            
            for(int d=0; d<4; d++) {
                int nx = now[0] + dx[d];
                int ny = now[1] + dy[d];
                
                if(nx<0 || nx>=n || ny<0 || ny>=n || cnt[nx][ny]!=0) continue;
                cnt[nx][ny] = cnt[now[0]][now[1]] + 1;
                que.add(new int[]{nx, ny});
            }
        }
        
        return -1;
    }
    
    
}
```
