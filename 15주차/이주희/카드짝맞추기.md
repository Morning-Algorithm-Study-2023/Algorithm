## 시도2
## 소요시간, 메모리
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/1109a613-7556-4db0-be4f-1d0205a8dce4)   
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/35b47f21-9cc8-4a84-a09b-b82bc2d4d305)

## 풀이
* 순열을 통해 카드를 뒤집을 순서를 구한다.
* bfs를 통해 최단 이동 거리를 구해 최종 답 answer를 갱신한다. 

## 코드
```Java
import java.util.*;

//카드를 뽑을 순서를 순열로 구함
//bfs로 이동하면서 answer를 최소값으로 갱신

class Solution {
    
    int n, answer;
    int[][] board;
    boolean[] cards;
    int r, c;
    int left;       //총 남은 카드의 갯수
    int card_n = 7;
    
    public int solution(int[][] board, int r, int c) {
        n = board.length;
        this.board = board;
        this.r = r; this.c = c;
        
        left = 0;
        cards = new boolean[card_n]; //1~6까지의 카드 유무 체크 
        for(int i=0; i<n; i++) {
            for(int j=0; j<n; j++) {
                if(board[i][j] ==0 || cards[board[i][j]]) continue;
                cards[board[i][j]] = true;
                left++;
            }
        }
        
        answer = Integer.MAX_VALUE;
        permutation(0, new int[left], new boolean[card_n]);
        return answer;
    }
    
    void permutation(int idx, int[] path, boolean[] visited) {
        if(idx == left) {
            bfs(path);
            return;
        }
        
        for(int i=1; i<card_n; i++) {
            if(visited[i] || !cards[i]) continue;
            visited[i] = true;
            path[idx] = i;
            
            permutation(idx+1, path, visited);
            
            visited[i] = false;
        }
    }
    
    int[] dx = {-1, 0, 1, 0};  //상, 우, 하, 좌
    int[] dy = {0, 1, 0, -1};
    
    void bfs(int[] path) {
        Queue<int[]> que = new ArrayDeque<>();
        que.add(new int[]{r, c});
        int idx = 0;
        int dist = 0;
        boolean[][] visited = new boolean[n][n];
        boolean[][] entered = new boolean[n][n];
        visited[r][c] = true;
        int res=0;
        boolean isPair = false;
        
        while(!que.isEmpty()) {
            int size = que.size();
            
            while(size-- > 0) {
                int[] now = que.poll();
                
                if(board[now[0]][now[1]] == path[idx] && !entered[now[0]][now[1]]) {
                    res += dist;
                    res += 1; //enter 연산
                    dist = -1;//루프 종료 후 +1 해주기 때문에 초기화 -1
                    visited = new boolean[n][n];
                    que = new ArrayDeque<>();
                    que.add(new int[]{now[0], now[1]});
                    visited[now[0]][now[1]] = true;
                    entered[now[0]][now[1]] = true;
                    
                    if(!isPair) {
                        isPair = true;
                    } else {
                        idx++;
                        isPair = false;
                    }
                    
                    if(idx >= left) {
                        answer = Math.min(answer, res);
                        return;
                    }
                    
                    break;
                    
                }
                
                //ctrl
                for(int d=0; d<4; d++) {
                    int nx = now[0], ny = now[1];

                    while(true) {
                        nx += dx[d];
                        ny += dy[d];

                        if(nx<0 || nx>=n || ny<0 || ny>=n) {
                            nx-=dx[d]; ny-=dy[d];
                            break;
                        }

                        if(board[nx][ny] != 0 && !entered[nx][ny]) break;
                    }

                    if(visited[nx][ny]) continue; 
                    visited[nx][ny] = true;
                    que.add(new int[]{nx, ny});
                }

                for(int d=0; d<4; d++) {
                    int nx = now[0] + dx[d];
                    int ny = now[1] + dy[d];

                    if(nx<0 || nx>=n || ny<0 || ny>=n || visited[nx][ny]) continue;
                    visited[nx][ny] = true;
                    que.add(new int[]{nx, ny});
                }
            }
            
            dist++;
        }
    }
}
```
</br>


## 시도 1 (틀렸습니다)
## 소요시간, 메모리
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/0650b771-22ac-43c8-88d0-59fe780c2b33)   
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/d5ac783f-6451-4ae4-bca2-def051d6eab6)   


## 코드
```Java
import java.util.*;

class Solution {
    
    int n, answer;
    int[][] board;
    int[] cur;
    
    public int solution(int[][] board, int r, int c) {
        n = board.length;
        this.board = board;
        
        int left = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<n; j++) {
                if(board[i][j] != 0) {
                    left++;
                }
            }
        }
        
        answer = 0;
        cur = new int[]{r, c};
        while(left > 0) {
            int target = board[cur[0]][cur[1]]; //타겟이 0이면, 카드를 찾아야 한다. 타겟이 숫자면 같은 숫자를 찾아야 한다. 
            left -= bfs(target);
        }
        
        return answer;
    }
    
    int[] dx = {-1, 0, 1, 0};  //상, 우, 하, 좌
    int[] dy = {0, 1, 0, -1};
    
    int bfs(int target) {
        Queue<int[]> que = new ArrayDeque<>();
        que.add(cur);
        boolean[][] visited = new boolean[n][n];
        visited[cur[0]][cur[1]] = true;
        int dist = 0;
        
        while(!que.isEmpty()) {
            
            int size = que.size();
            
            while(size-- > 0) {
                int[] now = que.poll();
            
                if(target==0 && board[now[0]][now[1]] != 0) {   //카드 찾음
                    answer += dist;  //이동
                    cur[0] = now[0]; cur[1] = now[1];
                    return 0;
                } 
                if(target != 0 && board[now[0]][now[1]] == target && (now[0] != cur[0] || now[1] != cur[1])) {   //짝 찾음
                    answer += dist;     //이동
                    answer += 2;        //enter연산
                    board[now[0]][now[1]] = 0;      //제거
                    board[cur[0]][cur[1]] = 0;      //제거
                    cur[0] = now[0]; cur[1] = now[1];
                    return 2;
                }

                //ctrl
                for(int d=0; d<4; d++) {
                    int nx = now[0], ny = now[1];

                    while(true) {
                        nx += dx[d];
                        ny += dy[d];

                        if(nx<0 || nx>=n || ny<0 || ny>=n) {
                            nx-=dx[d]; ny-=dy[d];
                            break;
                        }

                        if(board[nx][ny] != 0) break;
                    }

                    if(visited[nx][ny]) continue;    //이미 방문함
                    visited[nx][ny] = true;
                    que.add(new int[]{nx, ny});
                }

                for(int d=0; d<4; d++) {
                    int nx = now[0] + dx[d];
                    int ny = now[1] + dy[d];

                    if(nx<0 || nx>=n || ny<0 || ny>=n || visited[nx][ny]) continue;
                    visited[nx][ny] = true;
                    que.add(new int[]{nx, ny});
                }
            }
            
            dist++;
            
        }
        
        return -1;
    }
    
    
}
```
