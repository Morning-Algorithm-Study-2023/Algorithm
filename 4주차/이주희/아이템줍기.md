## 소요시간, 메모리
![image](https://github.com/Morning-Algorithm-Study-2023/Algorithm/assets/83942393/0edd3fff-044e-4a34-aef2-22fa3bd3bc98)

## 코드
```Java
import java.util.*;

class Solution {
    public int solution(int[][] rectangle, int characterX, int characterY, int itemX, int itemY) {
        int[][] board = new int[101][101];
        for(int[] rec : rectangle) {
            fill(rec[0]*2, rec[1]*2, rec[2]*2, rec[3]*2, board);
        }
        
        int res = bfs(characterX, characterY, itemX, itemY, board);
        return res/2;
    }
    
    void fill(int x1, int y1, int x2, int y2, int[][] board) {
        for(int x=x1; x<=x2; x++) {
            for(int y=y1; y<=y2; y++) {
                if(board[x][y]==2) continue;    // 사각형 내부

                board[x][y] = 2;
                if(x==x1 || y==y2 || x==x2 || y==y1) {  // 테투리
                    board[x][y] = 1;
                }
            }
        }
    }
    
    int bfs(int x, int y, int tx, int ty, int[][] board) {
        int answer = Integer.MAX_VALUE;
        x*=2; y*=2; tx*=2; ty*=2;
        
        int[] dx = {-1, 1, 0, 0}; //↑, ↓, ←, →
        int[] dy = {0, 0, -1, 1};
        int[][] visited = new int[101][101];
        Queue<int[]> que = new ArrayDeque<>();
        que.add(new int[]{x, y});
        visited[x][y] = 1;
        
        while(!que.isEmpty()) {
            int[] now = que.poll();
            if(now[0]==tx && now[1]==ty) {
                answer = Math.min(answer, visited[now[0]][now[1]]-1);
            }
            
            for(int d=0; d<4; d++) {
                int nx = now[0] + dx[d];
                int ny = now[1] + dy[d];
                
                if(nx<=0 || nx>100 || ny<=0 || ny>100 || visited[nx][ny] != 0 || board[nx][ny] != 1) continue;
                visited[nx][ny] = visited[now[0]][now[1]] + 1;
                que.add(new int[]{nx, ny});
            }
        }
        
        return answer;
    }
}
```
